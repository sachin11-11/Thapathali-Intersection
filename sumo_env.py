import os
import sys
import numpy as np

# Check for SUMO_HOME
if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    # Use the Eclipse SUMO installation path
    sumo_tools_path = "/Library/Frameworks/EclipseSUMO.framework/Versions/Current/EclipseSUMO/tools"
    if os.path.exists(sumo_tools_path):
        sys.path.append(sumo_tools_path)
    else:
        # Fallback to homebrew path
        sys.path.append("/opt/homebrew/opt/sumo/share/sumo/tools")

import traci

import config


class SumoEnvironment:
    """
    SUMO Environment wrapper for DQN traffic light control.
    """
    
    def __init__(self, use_gui=False):
        self.use_gui = use_gui
        self.sumo_binary = "sumo-gui" if use_gui else "sumo"
        self.sumo_cmd = [self.sumo_binary, "-c", config.SUMO_CONFIG_PATH, "--no-warnings"]
        
        self.tls_ids = list(config.TLS_IDS.values())
        self.current_phase = 0
        self.last_phase = 0
        self.time_since_last_action = 0
        self.step_count = 0
        
        # Will be populated after first reset
        self.incoming_lanes = []
        self.outgoing_lanes = []
        self.state_size = None
        
    def _get_lanes(self):
        """
        Get all unique incoming and outgoing lanes for the traffic lights.
        
        Returns:
            incoming_lanes: Unique lanes entering the intersection (controlled by TLS)
            outgoing_lanes: Unique lanes exiting the intersection
        """
        incoming = set()
        outgoing = set()
        
        for tls_id in self.tls_ids:
            # getControlledLanes() returns duplicates (same lane for different links)
            # So we use set() to keep only unique lanes
            controlled_lanes = traci.trafficlight.getControlledLanes(tls_id)
            for lane in controlled_lanes:
                incoming.add(lane)
                
                # Get outgoing lanes from this lane's connections
                links = traci.lane.getLinks(lane)
                for link in links:
                    # link[0] is the outgoing lane
                    # Only add if it's not also an incoming lane (avoid internal lanes)
                    if link[0]:  # Check if link exists
                        outgoing.add(link[0])
        
        # Remove any overlap - a lane shouldn't be both incoming and outgoing
        # (This handles internal junction lanes that might appear in both sets)
        outgoing = outgoing - incoming
        
        return sorted(list(incoming)), sorted(list(outgoing))
    
    def _get_lane_vehicle_count(self, lane):
        """Get number of vehicles on a lane."""
        try:
            return traci.lane.getLastStepVehicleNumber(lane)
        except:
            return 0
    
    def _get_state(self):
        """
        Get current state representation.
        State = [lane_1_count, lane_2_count, ..., lane_n_count, phase_one_hot]
        """
        # Get vehicle counts for each lane
        lane_counts = []
        for lane in self.incoming_lanes:
            lane_counts.append(self._get_lane_vehicle_count(lane))
        for lane in self.outgoing_lanes:
            lane_counts.append(self._get_lane_vehicle_count(lane))
        
        # One-hot encode current phase
        phase_one_hot = [0] * config.NUM_ACTIONS
        phase_one_hot[self.current_phase] = 1
        
        state = np.array(lane_counts + phase_one_hot, dtype=np.float32)
        return state
    
    def _calculate_reward(self):
        """
        Calculate reward using Max Pressure theory.
        R = -Σ (w(i) - 1/|L_out| * Σ w(j))
        """
        total_pressure = 0
        
        for incoming_lane in self.incoming_lanes:
            incoming_count = self._get_lane_vehicle_count(incoming_lane)
            
            # Calculate average outgoing count
            outgoing_sum = sum(self._get_lane_vehicle_count(lane) for lane in self.outgoing_lanes)
            avg_outgoing = outgoing_sum / len(self.outgoing_lanes) if len(self.outgoing_lanes) > 0 else 0
            
            pressure = incoming_count - avg_outgoing
            total_pressure += pressure
        
        reward = -total_pressure
        return reward
    
    def _set_phase(self, phase_idx):
        """
        Set traffic lights according to the phase.
        First set all lights to red, then enable specific lights for the phase.
        """
        # Set all lights to red (phase 2 is typically all-red in SUMO)
        for tls_id in self.tls_ids:
            try:
                # Get current state and set all to red
                current_state = traci.trafficlight.getRedYellowGreenState(tls_id)
                red_state = 'r' * len(current_state)
                traci.trafficlight.setRedYellowGreenState(tls_id, red_state)
            except:
                pass
        
        # Now set specific lights to green based on phase
        if phase_idx == 0:  # PHASE_1_STRAIGHTS
            # Maitighar <-> Kupondole
            try:
                traci.trafficlight.setPhase(config.TLS_IDS["maitighar_main"], 0)
                traci.trafficlight.setPhase(config.TLS_IDS["kupondole"], 0)
            except:
                pass
                
        elif phase_idx == 1:  # PHASE_2_MAITIGHAR_RIGHT
            # Maitighar -> Tripureshwor + Kupondole
            try:
                traci.trafficlight.setPhase(config.TLS_IDS["maitighar_right"], 0)
                traci.trafficlight.setPhase(config.TLS_IDS["maitighar_main"], 0)
            except:
                pass
                
        elif phase_idx == 2:  # PHASE_3_TRIPURESHWOR_STRAIGHT
            # Tripureshwor -> Maternity + Left
            try:
                traci.trafficlight.setPhase(config.TLS_IDS["tripureshwor"], 0)
                traci.trafficlight.setPhase(config.TLS_IDS["maternity"], 0)
            except:
                pass
                
        elif phase_idx == 3:  # PHASE_4_KUPONDOLE_RIGHT
            # Kupondole -> Maternity + Maitighar
            try:
                traci.trafficlight.setPhase(config.TLS_IDS["kupondole"], 0)
            except:
                pass
    
    def _set_yellow_phase(self):
        """Set all traffic lights to yellow."""
        for tls_id in self.tls_ids:
            try:
                current_state = traci.trafficlight.getRedYellowGreenState(tls_id)
                yellow_state = 'y' * len(current_state)
                traci.trafficlight.setRedYellowGreenState(tls_id, yellow_state)
            except:
                pass
    
    def reset(self):
        """Reset the environment."""
        # Close existing connection if any
        try:
            traci.close()
        except:
            pass
        
        # Start new simulation
        traci.start(self.sumo_cmd)
        
        # Initialize lanes
        self.incoming_lanes, self.outgoing_lanes = self._get_lanes()
        
        # Calculate state size
        self.state_size = len(self.incoming_lanes) + len(self.outgoing_lanes) + config.NUM_ACTIONS
        
        # Reset phase and counters
        self.current_phase = 0
        self.last_phase = 0
        self.time_since_last_action = 0
        self.step_count = 0
        
        # Set initial phase
        self._set_phase(self.current_phase)
        
        return self._get_state()
    
    def step(self, action):
        """
        Execute action and return (next_state, reward, done, info).
        
        Args:
            action: Phase index (0-3)
        """
        # Determine if we need to switch phase
        phase_switch = (action != self.current_phase)
        
        # If switching, apply yellow phase for 3 seconds
        if phase_switch:
            self._set_yellow_phase()
            for _ in range(config.YELLOW_PHASE_DURATION):
                if traci.simulation.getMinExpectedNumber() <= 0:
                    break
                traci.simulationStep()
                self.step_count += 1
        
        # Set the new phase
        self.current_phase = action
        self._set_phase(self.current_phase)
        
        # Execute green phase for ACTION_DURATION seconds
        total_reward = 0
        for _ in range(config.ACTION_DURATION):
            if traci.simulation.getMinExpectedNumber() <= 0:
                break
            traci.simulationStep()
            self.step_count += 1
            total_reward += self._calculate_reward()
        
        # Average reward over the action duration
        reward = total_reward / config.ACTION_DURATION
        
        # Get next state
        next_state = self._get_state()
        
        # Check if simulation is done
        done = (traci.simulation.getMinExpectedNumber() <= 0) or (self.step_count >= config.MAX_STEPS_PER_EPISODE)
        
        info = {
            'step_count': self.step_count,
            'phase': self.current_phase
        }
        
        return next_state, reward, done, info
    
    def close(self):
        """Close the environment."""
        try:
            traci.close()
        except:
            pass
    
    def get_state_size(self):
        """Return the size of the state space."""
        if self.state_size is None:
            raise RuntimeError("Environment must be reset before getting state size")
        return self.state_size
    
    def get_action_size(self):
        """Return the size of the action space."""
        return config.NUM_ACTIONS
